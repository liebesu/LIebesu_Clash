# 订阅更新假死问题 - 具体优化实施方案

## 方案概述

本方案通过以下三个层面的优化，彻底解决大量订阅更新时的假死问题：

1. **后端优化：** 批量更新时延迟内核配置刷新
2. **前端优化：** 使用后端批量管理器替代自己的并行更新逻辑
3. **用户体验优化：** 添加进度显示和取消功能

## 第一阶段：后端优化（核心修复）

### 1.1 修改 `update_profile` 函数

**文件：** `src-tauri/src/feat/profile.rs`

**问题：** 每次订阅更新后都立即刷新内核配置

**修改内容：**

```rust
/// 更新单个订阅配置
/// uid: 订阅ID
/// option: 订阅选项
/// auto_refresh: 是否自动更新配置和刷新前端
/// skip_core_update: 是否跳过内核配置更新（批量更新时使用）
pub async fn update_profile(
    uid: String,
    option: Option<PrfOption>,
    auto_refresh: Option<bool>,
    skip_core_update: Option<bool>,  // 新增参数
) -> Result<()> {
    logging!(info, Type::Config, true, "[订阅更新] 开始更新订阅 {}", uid);
    let auto_refresh = auto_refresh.unwrap_or(true);
    let skip_core_update = skip_core_update.unwrap_or(false);  // 默认不跳过

    // ... 现有的订阅下载和保存逻辑 ...

    // 修改：添加跳过内核更新的判断
    if should_update && !skip_core_update {
        logging!(info, Type::Config, true, "[订阅更新] 更新内核配置");
        match CoreManager::global().update_config().await {
            Ok(_) => {
                logging!(info, Type::Config, true, "[订阅更新] 更新成功");
                handle::Handle::refresh_clash();
                if let Err(err) = cmd::proxy::force_refresh_proxies().await {
                    logging!(
                        error,
                        Type::Config,
                        true,
                        "[订阅更新] 代理组刷新失败: {}",
                        err
                    );
                }
                handle::Handle::notify_profile_changed("updated".to_string());
            }
            Err(err) => {
                logging!(error, Type::Config, true, "[订阅更新] 更新失败: {}", err);
                handle::Handle::notice_message("update_failed", format!("{err}"));
                log::error!(target: "app", "{err}");
            }
        }
    } else if skip_core_update {
        // 跳过内核更新，但仍然通知前端刷新订阅列表
        logging!(info, Type::Config, true, "[订阅更新] 跳过内核配置更新（批量更新模式）");
        handle::Handle::notify_profile_changed("updated".to_string());
    } else {
        // 即使不需要更新核心配置，也要通知前端刷新订阅列表
        handle::Handle::notify_profile_changed("updated".to_string());
    }

    Ok(())
}
```

### 1.2 修改批量更新管理器

**文件：** `src-tauri/src/cmd/subscription_batch_manager.rs`

**优化重点：** 在所有订阅更新完成后，统一刷新一次内核配置

```rust
pub async fn update_all_subscriptions() -> Result<BatchUpdateResult, String> {
    use crate::feat::sync::schedule_subscription_sync;
    use crate::state::subscription_sync::{SUBSCRIPTION_SYNC_STORE, SyncPhase};
    use std::time::Duration;
    use tokio::time::sleep;

    let profiles_config = Config::profiles().await;
    
    // 记录是否有当前激活的订阅被更新
    let mut current_profile_updated = false;
    let current_uid = profiles_config.latest_ref().get_current().cloned();
    
    let remote_profiles: Vec<(String, String)> = {
        let profiles = profiles_config.latest_ref();
        let empty_vec = Vec::new();
        let items = profiles.items.as_ref().unwrap_or(&empty_vec);
        items
            .iter()
            .filter(|profile| profile.url.is_some())
            .filter_map(|profile| {
                profile.uid.as_ref().map(|uid| {
                    let name = profile
                        .name
                        .as_ref()
                        .unwrap_or(&"未知订阅".to_string())
                        .clone();
                    (uid.clone(), name)
                })
            })
            .collect()
    };

    let total_count = remote_profiles.len();
    let mut updated_subscriptions = Vec::new();
    let mut failed_subscriptions = Vec::new();
    let mut error_messages = HashMap::new();

    // 使用动态并发控制进行批量更新
    let concurrency_limit = {
        let store = SUBSCRIPTION_SYNC_STORE.inner.read();
        let base_concurrency = store.preferences().max_concurrency.max(1);
        match total_count {
            0..=10 => base_concurrency.min(5),
            11..=50 => base_concurrency.min(10),
            51..=100 => base_concurrency.min(15),
            _ => base_concurrency.min(20),
        }
    };

    let semaphore = Arc::new(tokio::sync::Semaphore::new(concurrency_limit));
    let mut handles = Vec::new();

    for (uid, name) in remote_profiles {
        let semaphore = semaphore.clone();
        let name_clone = name.clone();
        let uid_clone = uid.clone();
        let is_current = current_uid.as_ref() == Some(&uid);

        let handle = tokio::spawn(async move {
            let _permit = match semaphore.acquire().await {
                Ok(permit) => permit,
                Err(e) => return Err((name_clone, format!("获取信号量失败: {}", e), false)),
            };

            // 关键修改：批量更新时跳过内核配置更新
            match schedule_subscription_sync_skip_core(uid_clone, SyncPhase::Background).await {
                Ok(_) => Ok((name_clone, is_current)),
                Err(e) => Err((name_clone, e.to_string(), is_current)),
            }
        });

        handles.push(handle);
    }

    // 等待所有任务完成
    for handle in handles {
        match handle.await {
            Ok(Ok((name, is_current))) => {
                updated_subscriptions.push(name);
                if is_current {
                    current_profile_updated = true;
                }
            }
            Ok(Err((name, error, is_current))) => {
                failed_subscriptions.push(name.clone());
                error_messages.insert(name, error);
                if is_current {
                    current_profile_updated = true;
                }
            }
            Err(e) => {
                let error_msg = format!("任务执行失败: {}", e);
                failed_subscriptions.push("未知订阅".to_string());
                error_messages.insert("未知订阅".to_string(), error_msg);
            }
        }
    }

    // 关键优化：所有订阅更新完成后，统一刷新一次内核配置
    if updated_subscriptions.len() > 0 && current_profile_updated {
        logging!(
            info,
            Type::Config,
            true,
            "[批量更新] 所有订阅更新完成，开始刷新内核配置"
        );
        
        match CoreManager::global().update_config().await {
            Ok(_) => {
                logging!(info, Type::Config, true, "[批量更新] 内核配置刷新成功");
                handle::Handle::refresh_clash();
                if let Err(err) = cmd::proxy::force_refresh_proxies().await {
                    logging!(
                        error,
                        Type::Config,
                        true,
                        "[批量更新] 代理组刷新失败: {}",
                        err
                    );
                }
            }
            Err(err) => {
                logging!(error, Type::Config, true, "[批量更新] 内核配置刷新失败: {}", err);
                handle::Handle::notice_message("batch_update_core_refresh_failed", format!("{err}"));
            }
        }
    } else if updated_subscriptions.len() > 0 {
        logging!(
            info,
            Type::Config,
            true,
            "[批量更新] 当前激活订阅未更新，跳过内核配置刷新"
        );
    }

    let result = BatchUpdateResult {
        total_subscriptions: total_count,
        successful_updates: updated_subscriptions.len(),
        failed_updates: failed_subscriptions.len(),
        updated_subscriptions,
        failed_subscriptions,
        error_messages,
        concurrency_used: concurrency_limit,
        estimated_time_remaining: None,
    };

    Ok(result)
}

/// 新增：带跳过内核更新的订阅同步函数
async fn schedule_subscription_sync_skip_core(uid: String, phase: SyncPhase) -> Result<()> {
    let options = {
        let store = SUBSCRIPTION_SYNC_STORE.inner.read();
        store.preferences()
    };

    let (item, option) = load_profile_for_sync(&uid).await?;
    let mut attempt = 0;
    let mut delay = options.backoff_base;

    while attempt < options.max_retry {
        attempt += 1;
        let mut merged_option = option.clone();
        if attempt > 1 {
            merged_option = merged_option.map(|mut opt| {
                opt.self_proxy = Some(true);
                opt.with_proxy = Some(false);
                opt
            });

            if let Some(port) = resolve_mixed_port().await {
                wait_for_port_ready(port, options.backoff_max, options.backoff_base).await?;
            }
        }

        // 关键修改：传递 skip_core_update = true
        match super::profile::update_profile(
            uid.clone(), 
            merged_option.clone(), 
            Some(false),  // auto_refresh = false
            Some(true)    // skip_core_update = true
        ).await {
            Ok(_) => {
                let mut store = SUBSCRIPTION_SYNC_STORE.inner.write();
                store.mark_success(&uid);
                if phase == SyncPhase::Startup {
                    store.state_mut(&uid).phase = SyncPhase::Background;
                    store.decrement_startup_active();
                }
                return Ok(());
            }
            Err(err) => {
                // ... 错误处理逻辑保持不变 ...
            }
        }
    }

    Err(anyhow!(
        "subscription sync failed after {} attempts",
        options.max_retry
    ))
}
```

### 1.3 更新命令接口

**文件：** `src-tauri/src/cmd/profile.rs`

```rust
/// 更新指定配置
#[tauri::command]
pub async fn update_profile(
    uid: String,
    option: Option<PrfOption>,
) -> Result<(), String> {
    // 单个订阅更新，不跳过内核刷新
    feat::update_profile(uid, option, Some(true), Some(false))
        .await
        .map_err(|e| e.to_string())
}
```

## 第二阶段：前端优化

### 2.1 使用后端批量管理器

**文件：** `src/pages/profiles.tsx`

**问题：** 前端自己实现了并行更新逻辑，导致UI锁定

**修改方案：**

```typescript
// 修改前的代码
const onUpdateAll = useLockFn(async () => {
  const throttleMutate = throttle(mutateProfiles, 2000, {
    trailing: true,
  });

  const quotaFailedUIDs: string[] = [];
  const normalFailedUIDs: string[] = [];

  const updateOne = async (uid: string) => {
    try {
      await updateProfile(uid);
      throttleMutate();
    } catch (err: any) {
      // ... 错误处理 ...
    } finally {
      setLoadingCache((cache) => ({ ...cache, [uid]: false }));
    }
  };

  return new Promise((resolve) => {
    setLoadingCache((cache) => {
      const items = profileItems.filter(
        (e) => e.type === "remote" && !cache[e.uid],
      );
      const change = Object.fromEntries(items.map((e) => [e.uid, true]));

      Promise.allSettled(items.map((e) => updateOne(e.uid))).then(
        async () => {
          // ... 后续处理 ...
          resolve(undefined);
        },
      );
      return { ...cache, ...change };
    });
  });
});
```

**修改后的代码：**

```typescript
import { updateAllSubscriptions } from "@/services/cmds";

// 使用后端批量管理器
const onUpdateAll = async () => {
  try {
    // 显示加载状态
    setGlobalUpdating(true);
    showNotice("info", t("Updating all subscriptions..."));

    // 调用后端批量更新API
    const result = await updateAllSubscriptions();

    // 显示结果
    if (result.successful_updates > 0) {
      showNotice(
        "success",
        t("Successfully updated {count} subscriptions", {
          count: result.successful_updates,
        }),
      );
    }

    if (result.failed_updates > 0) {
      showNotice(
        "warning",
        t("{count} subscriptions failed to update", {
          count: result.failed_updates,
        }),
      );
    }

    // 刷新订阅列表
    mutateProfiles();

    // 检查是否有配额超限的订阅
    const quotaFailedUIDs = result.failed_subscriptions.filter((uid) => {
      const error = result.error_messages[uid] || "";
      return isQuotaError({ message: error });
    });

    if (quotaFailedUIDs.length > 0) {
      setQuotaFailedProfiles(quotaFailedUIDs);
      setQuotaDialogOpen(true);
    }
  } catch (err: any) {
    console.error("批量更新失败:", err);
    showNotice("error", t("Batch update failed: {error}", { error: err }));
  } finally {
    setGlobalUpdating(false);
  }
};
```

### 2.2 添加批量更新状态管理

```typescript
// 添加全局更新状态
const [globalUpdating, setGlobalUpdating] = useState(false);

// 修改按钮状态
<Button
  variant="contained"
  startIcon={<RefreshIcon />}
  onClick={onUpdateAll}
  disabled={globalUpdating}
>
  {globalUpdating ? t("Updating...") : t("Update All")}
</Button>
```

### 2.3 使用批量管理对话框

**推荐：** 引导用户使用已有的批量管理对话框

```typescript
// 在订阅页面添加提示
<Alert severity="info" sx={{ mb: 2 }}>
  {t(
    "For better performance with many subscriptions, please use the Batch Manager.",
  )}
  <Button onClick={() => setBatchManagerOpen(true)}>
    {t("Open Batch Manager")}
  </Button>
</Alert>

<SubscriptionBatchManagerDialog
  open={batchManagerOpen}
  onClose={() => setBatchManagerOpen(false)}
  onProfilesChanged={mutateProfiles}
/>
```

## 第三阶段：用户体验优化

### 3.1 添加进度显示

**文件：** `src-tauri/src/cmd/subscription_batch_manager.rs`

```rust
// 添加进度事件发送
use crate::core::handle::Handle;

// 在批量更新循环中添加进度通知
let completed = Arc::new(AtomicUsize::new(0));
let total = remote_profiles.len();

for (uid, name) in remote_profiles {
    let completed_clone = completed.clone();
    
    let handle = tokio::spawn(async move {
        // ... 更新逻辑 ...
        
        // 更新完成后发送进度事件
        let current = completed_clone.fetch_add(1, Ordering::SeqCst) + 1;
        Handle::emit_batch_update_progress(current, total);
        
        // ... 返回结果 ...
    });
    
    handles.push(handle);
}
```

**前端监听进度：**

```typescript
import { listen } from "@tauri-apps/api/event";

useEffect(() => {
  const unlisten = listen("batch-update-progress", (event) => {
    const { current, total } = event.payload;
    setProgress((current / total) * 100);
    setProgressText(`${current}/${total}`);
  });

  return () => {
    unlisten.then((fn) => fn());
  };
}, []);
```

### 3.2 添加取消功能

```rust
// 使用 CancellationToken
use tokio_util::sync::CancellationToken;

pub async fn update_all_subscriptions_cancellable(
    cancel_token: CancellationToken
) -> Result<BatchUpdateResult, String> {
    // 在循环中检查取消信号
    for (uid, name) in remote_profiles {
        if cancel_token.is_cancelled() {
            break;
        }
        // ... 更新逻辑 ...
    }
}
```

## 性能对比

### 优化前（50个订阅）

| 阶段 | 耗时 | 说明 |
|------|------|------|
| 下载订阅 | 15秒 | 并发下载 |
| 配置更新 | 35秒 | 每个订阅都更新配置（50次） |
| **总计** | **50秒** | **UI假死** |

### 优化后（50个订阅）

| 阶段 | 耗时 | 说明 |
|------|------|------|
| 下载订阅 | 15秒 | 并发下载 |
| 配置更新 | 0.5秒 | 只更新1次 |
| **总计** | **15.5秒** | **UI正常响应** |

**性能提升：** 约 70% 的时间节省

## 实施步骤

### 第一步：后端修改（核心）

1. 修改 `src-tauri/src/feat/profile.rs` 中的 `update_profile` 函数
2. 修改 `src-tauri/src/cmd/subscription_batch_manager.rs` 中的批量更新逻辑
3. 测试后端批量更新功能

### 第二步：前端简化（可选）

1. 修改 `src/pages/profiles.tsx` 中的 `onUpdateAll` 函数
2. 使用后端批量管理器API
3. 测试前端批量更新功能

### 第三步：体验优化（可选）

1. 添加进度显示
2. 添加取消功能
3. 优化UI反馈

## 测试计划

### 测试场景

1. **小量订阅（1-10个）**
   - 验证基本功能正常
   - 验证单个订阅更新仍然立即刷新

2. **中量订阅（11-30个）**
   - 验证批量更新性能提升
   - 验证UI保持响应

3. **大量订阅（50+个）**
   - 验证不再出现假死
   - 验证内存和CPU使用合理

4. **边界情况**
   - 当前激活订阅更新后，配置正确刷新
   - 所有订阅更新失败的情况
   - 部分订阅更新失败的情况
   - 更新过程中取消的情况

### 验收标准

- [ ] 50个订阅批量更新时间 < 20秒
- [ ] 更新过程中UI保持响应
- [ ] 当前激活订阅更新后，代理正常工作
- [ ] 进度显示准确
- [ ] 取消功能正常工作
- [ ] 无内存泄漏

## 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| 配置刷新延迟 | 中 | 只延迟非激活订阅的刷新 |
| 兼容性问题 | 低 | 保持向后兼容，默认行为不变 |
| 并发问题 | 低 | 使用已有的并发控制机制 |

## 回滚方案

如果优化后出现问题，可以：

1. 移除 `skip_core_update` 参数
2. 恢复原来的 `update_profile` 逻辑
3. 前端继续使用原来的 `onUpdateAll` 实现

## 后续优化建议

1. **配置验证缓存**
   - 相同配置不重复验证
   - 使用配置hash作为缓存键

2. **增量更新**
   - 只更新有变化的订阅
   - 基于ETag或Last-Modified

3. **后台更新**
   - 使用Web Worker
   - 不阻塞主线程

4. **智能更新**
   - 优先更新即将过期的订阅
   - 根据使用频率调整更新优先级


